[{"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/dynamical_type_aliases.rst", "origination_method": "extract_from_library_automatic", "code": "from typing import Union, Mapping, Callable, TypeVar\nimport numbers\nimport torch\n\nT = TypeVar('T')\n\nR = Union[numbers.Real, torch.Tensor]", "description": "Defines a type alias `R` which can be either a real number (`numbers.Real`) or a PyTorch tensor (`torch.Tensor`), representing a scalar value in this context."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/dynamical_type_aliases.rst", "origination_method": "extract_from_library_automatic", "code": "from typing import Union, Mapping, Callable, TypeVar\nimport numbers\nimport torch\n\nT = TypeVar('T')\n\nR = Union[numbers.Real, torch.Tensor]\n\nState = Mapping[str, T]", "description": "Introduces a type alias `State` representing the state of a system as a mapping (dict) where keys are strings and values are of a generic type `T`, which can denote variable types or their rates of change."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/dynamical_type_aliases.rst", "origination_method": "extract_from_library_automatic", "code": "from typing import Union, Mapping, Callable, TypeVar\nimport numbers\nimport torch\n\nT = TypeVar('T')\n\nR = Union[numbers.Real, torch.Tensor]\n\nState = Mapping[str, T]\n\nDynamics = Callable[[State[T]], State[T]]", "description": "Defines a type alias `Dynamics` for a callable (function type) that models the dynamics of a system. It takes a `State[T]` and returns a new `State[T]`, which maps state variable names to their rates of change."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/tutorial_i.ipynb", "origination_method": "extract_from_library_automatic", "code": "import os\nimport pyro\nfrom pyro.distributions import Bernoulli\n\nsmoke_test = ('CI' in os.environ)\nnum_samples = 1000 if not smoke_test else 10\nnum_iterations = 1000 if not smoke_test else 10\nn_individuals = 10000 if not smoke_test else 10\n\ndef causal_model(stress_pt, smokes_cpt, cancer_cpt):\nstress = pyro.sample(\"stress\", Bernoulli(stress_pt))\nsmokes = pyro.sample(\"smokes\", Bernoulli(smokes_cpt[stress.long()]))\ncancer = pyro.sample(\"cancer\", Bernoulli(cancer_cpt[stress.long(), smokes.long()]))\nreturn smokes", "description": "Defines a basic causal model relating stress, smoking, and cancer, using specified probability tables for stress, smoking conditional on stress, and cancer conditional on stress and smoking."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/tutorial_i.ipynb", "origination_method": "extract_from_library_automatic", "code": "import torch\n\nstress_pt = torch.tensor([0.5])\nsmokes_cpt  = torch.tensor([0.2, 0.8])\ncancer_cpt  = torch.tensor([[0.1, 0.15],\n                              [0.8, 0.85]])\n\npyro.render_model(causal_model, (stress_pt, smokes_cpt, cancer_cpt))", "description": "Sets up and visualizes the causal model with fixed parameters for stress, smoking, and cancer, and uses Pyro's render_model function."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/tutorial_i.ipynb", "origination_method": "extract_from_library_automatic", "code": "def forced_smokes_model(stress_pt, smokes_cpt, cancer_cpt, smokes_assignment):\n    stress = pyro.sample(\"stress\", Bernoulli(stress_pt))\n    smokes = pyro.deterministic(\"smokes\", smokes_assignment)\n    cancer = pyro.sample(\"cancer\", Bernoulli(cancer_cpt[stress.int(), smokes.int()]))\n    return smokes", "description": "Modifies the original causal model to simulate a scenario where smoking is externally assigned (forced), rather than being a probabilistic outcome."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/tutorial_i.ipynb", "origination_method": "extract_from_library_automatic", "code": "from pyro.distributions import Beta\n\ndef parameter_prior():\n    stress_pt = pyro.sample(\"stress_pt\", Beta(1., 1.))\n    smokes_cpt = pyro.sample(\"smokes_cpt\", Beta(torch.ones(2), torch.ones(2)).to_event(1))\n    cancer_cpt = pyro.sample(\"cancer_cpt\", Beta(torch.ones(2, 2), torch.ones(2, 2)).to_event(2))\n    return stress_pt, smokes_cpt, cancer_cpt", "description": "Defines a prior distribution over model parameters using Beta distributions, introducing uncertainty into the causal model."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/tutorial_i.ipynb", "origination_method": "extract_from_library_automatic", "code": "from chirho.interventional.handlers import do\n\ndef forced_smokes_model(stress_pt, smokes_cpt, cancer_cpt, smokes_assignment):\n    transformed_model = do(causal_model, {\"smokes\": smokes_assignment})\n    return transformed_model(stress_pt, smokes_cpt, cancer_cpt)", "description": "Uses ChiRho's `do` operation to create an intervened version of the causal model programmatically, instead of manually modifying the model code."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/tutorial_i.ipynb", "origination_method": "extract_from_library_automatic", "code": "from chirho.counterfactual.handlers import TwinWorldCounterfactual\ntwin_model = TwinWorldCounterfactual()(bayesian_randomized_model)\ntwin_model(n_individuals)", "description": "Applies the `TwinWorldCounterfactual` effect handler from ChiRho to create a model that describes both the observed (factual) and unobserved (counterfactual) worlds under interventions."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/tutorial_i.ipynb", "origination_method": "extract_from_library_automatic", "code": "from pyro.infer.autoguide import AutoNormal\nfrom pyro.infer import SVI\n\nadam = pyro.optim.Adam({'lr': 0.03})\nelbo = pyro.infer.Trace_ELBO()\nguide = AutoNormal(block(twin_model_conditioned, expose=['stress_pt', 'smokes_cpt', 'cancer_cpt']))\nsvi = SVI(twin_model_conditioned, guide, adam, loss=elbo)\n\nfor j in range(num_iterations):\n    loss = svi.step(n_individuals)\n    if j % 100 == 0:\n        print(\"[iteration %04d] loss: %.4f\" % (j + 1, loss / n_individuals))", "description": "Sets up and runs stochastic variational inference (SVI) using Pyro, to approximate the posterior over model parameters and counterfactual outcomes based on observational data."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/slc.ipynb", "origination_method": "extract_from_library_automatic", "code": "#!/usr/bin/env python\n# coding: utf-8\n\nimport os\nimport torch\nimport pyro\nimport torch.nn as nn\nimport pyro.distributions as dist\nimport numpy as np\nimport pandas as pd\nimport pytorch_lightning as pl\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom torch import Tensor\nfrom pyro.nn import PyroModule, PyroParam, PyroSample\nfrom chirho.counterfactual.handlers import MultiWorldCounterfactual\nfrom chirho.indexed.ops import IndexSet, gather, indices_of\nfrom chirho.interventional.handlers import do\nfrom chirho.observational.handlers import condition\n\npyro.clear_param_store()\npyro.set_rng_seed(1234)\npyro.settings.set(module_local_params=True)\n\nsmoke_test = ('CI' in os.environ)\nmax_epochs = 5 if smoke_test else 2000\nnum_samples = 10 if smoke_test else 10000", "description": "Initial setup for probabilistic programming with Pyro including imports, Pyro setup, and environment configuration for testing."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/slc.ipynb", "origination_method": "extract_from_library_automatic", "code": "DATA_URL = \"https://raw.githubusercontent.com/avehtari/ROS-Examples/master/ElectricCompany/data/electric.csv\"\ndf = pd.read_csv(DATA_URL, delimiter=\",\", index_col=0)\ndf = df.drop(\"supp\", axis=1)", "description": "Loading and preprocessing of the data used in the Electric Company Education Study."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/slc.ipynb", "origination_method": "extract_from_library_automatic", "code": "sns.pairplot(df.drop(\"pair_id\", axis=1), hue=\"grade\", diag_kind=\"hist\")", "description": "Visualizing the pre-processed dataset using a seaborn pairplot, with hue based on the 'grade' column."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/slc.ipynb", "origination_method": "extract_from_library_automatic", "code": "treated_df = df[df[\"treatment\"] == 1]\ncontrol_df = df[df[\"treatment\"] == 0]\n\n...\n\nd_X = 5\nn_instances = 2\nn_objects = 96\n\nX_obs = np.ones((n_instances, n_objects, d_X))\nX_obs[0, :, 0]  = control_df[\"pre_test\"].values\nX_obs[0, :, 1:] = pd.get_dummies(control_df[\"grade\"]).values\nX_obs[1, :, 0]  = treated_df[\"pre_test\"].values\nX_obs[1, :, 1:] = pd.get_dummies(treated_df[\"grade\"]).values\nT_obs = np.ones((n_instances, n_objects))\nT_obs[0, :] = 0.\nY_obs = np.ones((n_instances, n_objects))\nY_obs[0, :] = control_df[\"post_test\"].values\nY_obs[1, :] = treated_df[\"post_test\"].values\n\nX_obs = torch.tensor(X_obs).float()\nT_obs = torch.tensor(T_obs).float()\nY_obs = torch.tensor(Y_obs).float()", "description": "Preparation of data for SLC models, involving processing covariates, separating treatment and control groups, and converting data to PyTorch tensors."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/slc.ipynb", "origination_method": "extract_from_library_automatic", "code": "class BayesianLinear(pyro.nn.PyroModule):\n\n    def __init__(self, n_inputs: int, n_outputs: int):\n        super().__init__()\n        ...\n\n    def forward(self, *xs: torch.Tensor) -> torch.Tensor:\n        ...\n\n    @PyroSample\n    def weight(self):\n        ...\n\n    @PyroSample\n    def bias(self):\n        ...\n\n\nclass LinearSLC(pyro.nn.PyroModule):\n    ...\n\n    def forward(self):\n        ...\n\nlinear_slc = LinearSLC(d_X=d_X, n_objects=n_objects, n_instances=n_instances, d_U=2)\npyro.render_model(linear_slc)", "description": "Definition of the LinearSLC class for the structured latent confounder model, incorporating Bayesian linear models for different aspects of the data generation process."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/slc.ipynb", "origination_method": "extract_from_library_automatic", "code": "def plot_predictive(model, X_obs, T_obs, guide=None):\n    ...\n\n    plot_predictive(linear_slc, X_obs, T_obs, None)", "description": "Visualization function for plotting the predictive distribution of the model, demonstrating prior predictive checks."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/slc.ipynb", "origination_method": "extract_from_library_automatic", "code": "class LinearSLCITE(pyro.nn.PyroModule):\n    ...\n\n    def forward(self, X_obs, T_obs, Y_obs):\n        ...\n\nlinear_slc_ite = LinearSLCITE(linear_slc)\npyro.render_model(linear_slc_ite, model_args=(X_obs, T_obs, Y_obs))", "description": "Extension of the LinearSLC model to estimate Individual Treatment Effects (ITE) using the LinearSLCITE class."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/slc.ipynb", "origination_method": "extract_from_library_automatic", "code": "class LightningSVI(pl.LightningModule):\n    ...\n\nguide = pyro.infer.autoguide.AutoNormal(pyro.poutine.block(hide=[\"Y_counterfactual\"])(linear_slc_ite))\nelbo = pyro.infer.Trace_ELBO(num_particles=10, vectorize_particles=True)\nelbo = elbo(linear_slc_ite, guide)\n\n...\n\nsvi = LightningSVI(elbo, lr=0.03)\ntrainer = pl.Trainer(max_epochs=max_epochs, log_every_n_steps=1)\ntrainer.fit(svi, train_dataloaders=train_dataloader)", "description": "Implementation of Mean Field Variational Inference using Pyro's AutoNormal guide and PyTorch Lightning for optimizing the ELBO."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/slc.ipynb", "origination_method": "extract_from_library_automatic", "code": "predictive = pyro.infer.Predictive(linear_slc_ite, guide=guide, num_samples=num_samples, parallel=False)\nmf_prediction = predictive(X_obs, T_obs, Y_obs)[\"ITE\"]\n\nplot_predictive(linear_slc, X_obs, T_obs, guide=guide)", "description": "Using the Predictive class for generating posterior predictive samples and visualizing the posterior predictive distribution."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/slc.ipynb", "origination_method": "extract_from_library_automatic", "code": "naive_prediction = Y_obs[1, :] - Y_obs[0, :]\n\n...\n\nfor i in range(4):\n    ax[i].hist(mf_prediction[mf_grade_index[..., i]].reshape((mf_prediction.shape[0], -1)).mean(-1).detach().cpu().numpy(), bins=50, density=True, color=\"blue\", alpha=0.5, label=\"Mean Field\")\n    ax[i].vlines(naive_prediction[naive_index[..., 0, :, i]].mean(-1).detach().cpu().numpy(), 0, 1, color=\"red\", label=\"Naive Estimate\")", "description": "Comparison of Mean Field posterior predictive distribution with naive ATE estimates across different school grades."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/sciplex.ipynb", "origination_method": "extract_from_library_automatic", "code": "#! /usr/bin/env python\n# coding: utf-8\nget_ipython().run_line_magic('load_ext', 'autoreload')\nget_ipython().run_line_magic('autoreload', '2')\nget_ipython().run_cell_magic('capture', '', '!pip install scanpy pybiomart numpy==1.23 seaborn==0.12.2 # add single cell dependencies\n')\nimport os\nimport math\nimport numpy as np\nimport scipy.sparse\nimport pandas as pd\nimport scanpy as sc\nfrom scipy.stats import pearsonr\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pyro\nfrom pyro.infer.autoguide import AutoNormal\nfrom pyro.nn import PyroModule\nimport pyro.distributions as dist\nfrom IPython.display import Image\nimport torch\nfrom chirho.counterfactual.handlers import MultiWorldCounterfactual\nfrom chirho.indexed.ops import IndexSet, gather\nfrom chirho.interventional.handlers import do\nfrom chirho.observational.handlers import condition\npyro.clear_param_store()\npyro.set_rng_seed(1234)\npyro.settings.set(module_local_params=True)\nsns.set_style(\"white\")", "description": "Initial setup with package installations, imports, PyTorch, Pyro setup, and plotting configuration."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/sciplex.ipynb", "origination_method": "extract_from_library_automatic", "code": "if not os.path.exists(\"SrivatsanTrapnell2020_sciplex3_debugged.h5\"):\n    os.system('wget -c https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM4150nnn/GSM4150378/suppl/GSM4150378_sciPlex3_A549_MCF7_K562_screen_UMI.count.matrix.gz')\n    os.system('wget -c https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM4150nnn/GSM4150378/suppl/GSM4150378_sciPlex3_A549_MCF7_K562_screen_gene.annotations.txt.gz')\n    os.system('wget -c https://ftp.ncbi.nlm.nih.gov/geo/samples/GSM4150nnn/GSM4150378/suppl/GSM4150378_sciPlex3_pData.txt.gz')\n    os.system('gunzip GSM4150378_sciPlex3_A549_MCF7_K562_screen_UMI.count.matrix.gz')\n    os.system('gunzip GSM4150378_sciPlex3_A549_MCF7_K562_screen_gene.annotations.txt.gz')\n    os.system('gunzip GSM4150378_sciPlex3_pData.txt.gz')\nelse:\n    anndata = sc.read_h5ad(\"SrivatsanTrapnell2020_sciplex3_debugged.h5\")", "description": "Code to download and unzip SciPlex3 data if it is not already present, and load data using Scanpy."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/sciplex.ipynb", "origination_method": "extract_from_library_automatic", "code": "anndata = anndata[~anndata.obs['cell_type'].isnull()]\nanndata = anndata[anndata.obs['time_point'] == 24]\nannot = sc.queries.biomart_annotations(\"hsapiens\", [\"ensembl_gene_id\", \"hgnc_symbol\"])\nannot = annot.dropna()\nanndata = anndata[:, anndata.var['ensembl_gene_id'].isin(annot['ensembl_gene_id'].values)]\nsc.pp.filter_genes(anndata, min_cells=10)\nsc.pp.filter_cells(anndata, min_genes=200)", "description": "Preprocessing the dataset to remove unknown cell types, filter to 24hr observations, retain human genes, and remove genes expressed in fewer than 10 cells and cells with fewer than 200 expressed genes."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/sciplex.ipynb", "origination_method": "extract_from_library_automatic", "code": "drug_data = anndata[anndata.obs.product_name.str.contains(\"Pracinostat|Vehi\")]\nanndata = None # save on memory", "description": "Filtering the data to include only cells treated with Pracinostat or vehicle to conserve memory."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/sciplex.ipynb", "origination_method": "extract_from_library_automatic", "code": "drug_target = \"Pracinostat (SB939)\"\nwiki_genes = ['NCOA3', 'MYB', 'E2F1', 'KLF1', 'FEN1', 'GATA1', 'HNF4A', 'XRCC6', 'NFKB1', 'PCNA', 'TP53', 'RB1', 'RUNX1', 'SF1', 'SP3', 'STAT1', 'GTF2E1', 'TCF7L2', 'YY1', 'SIRT2']\nchipseq_a549_targets = [\"PSME2\", \"RNF31\", \"EMC9\", \"METTL26\", \"NPY4R\"]\nchipseq_k562_targets = [\"ZBTB4\", \"POLR2A\", \"UFD1\", \"CDC45\", 'SLC9A5']\nchipseq_mcf7_targets = [\"IDI1\", \"MAFG\", \"LAM...", "description": "Defining genes of interest for the analysis, including those from Wikipedia on histone deacetylase inhibitors, and genes identified from ChipSeq data."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/sciplex.ipynb", "origination_method": "extract_from_library_automatic", "code": "class DrugPerturbationModel(PyroModule):\n    def __init__(self, num_cells: int, num_genes: int, num_observed_confounders: int, num_latent_confounders: int = 3):\n        super().__init__()\n        self.num_cells = num_cells\n        self.num_genes = num_genes\n        self.num_observed_confounders = num_observed_confounders\n        self.num_latent_confounders = num_latent_confounders\n        self.num_confounders = num_observed_confounders + num_latent_confounders\n        self.cell_plate = pyro.plate(\"cells\", self.num_cells, dim=-2)\n        self.gene_plate =...", "description": "Define a Pyro model for drug perturbation incorporating latent and observed confounders."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/sciplex.ipynb", "origination_method": "extract_from_library_automatic", "code": "X_confounders = pd.get_dummies(drug_data.obs[['cell_type', 'replicate', 'culture_plate', 'pcr_plate', 'well_oligo']], dtype=np.int32).reset_index(drop=True)\nlog_umi = np.log(drug_data.obs['n.umi'].values)\nscaled_log_umi = (log_umi - np.mean(log_umi)) / log_umi.std()\nX_confounders['depth_proxy'] = scaled_log_umi\nT_all = pd.get_dummies(drug_data.obs[['product_name']], dtype=np.int32).reset_index(drop=True)\nT_all = T_all.mul(np.log10(drug_data.obs['dose'].values + 1), axis=0)\nX_drug_control = torch.tensor(X_confounders.values, dtype=torch.float32)\nT_drug_co...", "description": "Creating data matrices for the model, including one-hot encoding categorical confounders and converting dosages to log scale."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/sciplex.ipynb", "origination_method": "extract_from_library_automatic", "code": "class DrugPerturbationATE(pyro.nn.PyroModule):\n    def __init__(self, model: DrugPerturbationModel, X_pop: torch.tensor):\n        super().__init__()\n        self.model = model\n        self.X_pop = X_pop\n\n    def forward(self, dose_levels: tuple):\n        dose_levels = (torch.tensor(0.),) + tuple(torch.as_tensor(dose_level) for dose_level in dose_levels)\n        with MultiWorldCounterfactual(), do(actions={\"drug\": dose_levels}), \\\n        condition(data=dict(observed_confounders=self.X_pop[:, None, :])):\n            expressions = self.model()\n      ...", "description": "Defining a class to compute the average treatment effect (ATE) of drug perturbation using Pyro's probabilistic modeling framework."}, {"origination_source_type": "doc_file", "origination_source": "/media/hdd/Code/beaker-bio/src/beaker_bio_context/chiro/documentation/sciplex.ipynb", "origination_method": "extract_from_library_automatic", "code": "class DrugPerturbationCATE(pyro.nn.PyroModule):\n    def __init__(self, model: DrugPerturbationModel):\n        super().__init__()\n        self.model = model\n\n    def forward(self, dose_levels: tuple, X: torch.tensor, T: torch.tensor, Y: torch.tensor):\n        dose_levels = (torch.tensor(0.),) + tuple(torch.as_tensor(dose_level) for dose_level in dose_levels)\n        with MultiWorldCounterfactual(), do(actions={\"drug\": dose_levels}), \\\n        condition(data={\"observed_confounders\": X[:, None, :], \"drug\": T[..., None], \"gene_expression\": Y}):\n ...", "description": "Defining a class to compute the conditional average treatment effect (CATE) that incorporates cell-specific confounders into the modeling process."}]